using UnityEngine;
using UnityEngine.Tilemaps;
using System.Collections.Generic;
using System.Linq;

/// <summary>
/// Fixes L-shaped tile collision by removing unwanted 45° slopes generated by Composite Collider.
/// Attach this to GameObjects with Composite Collider 2D that contain L-shaped tiles.
/// </summary>
[RequireComponent(typeof(CompositeCollider2D))]
public class LShapeColliderFixer : MonoBehaviour
{
    [Header("Settings")]
    [Tooltip("Automatically fix slopes when the composite collider regenerates")]
    public bool autoFix = true;
    
    [Tooltip("Minimum angle (in degrees) to consider a slope for removal")]
    [Range(30f, 60f)]
    public float minSlopeAngle = 35f;
    
    [Tooltip("Maximum angle (in degrees) to consider a slope for removal")]
    [Range(40f, 70f)]
    public float maxSlopeAngle = 55f;
    
    private CompositeCollider2D compositeCollider;
    private Tilemap tilemap;
    
    void Start()
    {
        compositeCollider = GetComponent<CompositeCollider2D>();
        tilemap = GetComponent<Tilemap>();
        
        if (autoFix)
        {
            // Fix slopes after initial generation
            Invoke(nameof(FixLShapeSlopes), 0.1f);
        }
    }
    
    void Update()
    {
        if (autoFix && compositeCollider.pathCount != GetPreviousPathCount())
        {
            // Composite collider has regenerated, fix slopes again
            Invoke(nameof(FixLShapeSlopes), 0.1f);
        }
    }
    
    private int previousPathCount = -1;
    
    private int GetPreviousPathCount()
    {
        int current = previousPathCount;
        previousPathCount = compositeCollider.pathCount;
        return current;
    }
    
    /// <summary>
    /// Main method to fix L-shape slopes in the composite collider
    /// </summary>
    [ContextMenu("Fix L-Shape Slopes")]
    public void FixLShapeSlopes()
    {
        if (compositeCollider == null || tilemap == null)
        {
            Debug.LogWarning("LShapeColliderFixer: Missing required components");
            return;
        }
        
        Debug.Log($"LShapeColliderFixer: Analyzing {compositeCollider.pathCount} paths for L-shape slopes");
        
        // Get all L-shaped tile positions
        var lShapeTilePositions = GetLShapeTilePositions();
        
        if (lShapeTilePositions.Count == 0)
        {
            Debug.Log("LShapeColliderFixer: No L-shaped tiles found");
            return;
        }
        
        Debug.Log($"LShapeColliderFixer: Found {lShapeTilePositions.Count} L-shaped tiles");
        
        // For each path in the composite collider, check if it contains problematic slopes
        for (int pathIndex = 0; pathIndex < compositeCollider.pathCount; pathIndex++)
        {
            AnalyzeAndFixPath(pathIndex, lShapeTilePositions);
        }
    }
    
    /// <summary>
    /// Get all tile positions that contain L-shaped OffsetTiles
    /// </summary>
    private HashSet<Vector3Int> GetLShapeTilePositions()
    {
        var lShapePositions = new HashSet<Vector3Int>();
        
        BoundsInt bounds = tilemap.cellBounds;
        
        for (int x = bounds.xMin; x < bounds.xMax; x++)
        {
            for (int y = bounds.yMin; y < bounds.yMax; y++)
            {
                Vector3Int position = new Vector3Int(x, y, 0);
                TileBase tile = tilemap.GetTile(position);
                
                if (tile is OffsetTile offsetTile && IsLShapeTile(offsetTile))
                {
                    lShapePositions.Add(position);
                }
            }
        }
        
        return lShapePositions;
    }
    
    /// <summary>
    /// Determine if an OffsetTile represents an L-shape based on its sprite name
    /// </summary>
    private bool IsLShapeTile(OffsetTile offsetTile)
    {
        if (offsetTile.sprite == null) return false;
        
        string spriteName = offsetTile.sprite.name.ToLower();
        
        // Check for L-shape naming patterns from OffsetTileSlicerTool
        return spriteName.Contains("_l_missing_") || 
               spriteName.Contains("75_") ||
               (spriteName.Contains("missing") && 
                (spriteName.Contains("tr") || spriteName.Contains("tl") || 
                 spriteName.Contains("br") || spriteName.Contains("bl")));
    }
    
    /// <summary>
    /// Analyze a specific path for problematic slopes and attempt to fix them
    /// </summary>
    private void AnalyzeAndFixPath(int pathIndex, HashSet<Vector3Int> lShapeTilePositions)
    {
        List<Vector2> pathPoints = new List<Vector2>();
        compositeCollider.GetPath(pathIndex, pathPoints);
        
        if (pathPoints.Count < 3)
            return;
        
        var problematicSegments = FindProblematicSlopes(pathPoints, lShapeTilePositions);
        
        if (problematicSegments.Count > 0)
        {
            Debug.Log($"LShapeColliderFixer: Path {pathIndex} has {problematicSegments.Count} problematic slopes");
            
            // For now, just log the problematic segments
            // In a full implementation, you would modify the path here
            foreach (var segment in problematicSegments)
            {
                Vector2 start = pathPoints[segment.startIndex];
                Vector2 end = pathPoints[segment.endIndex];
                float angle = segment.angle;
                
                Debug.Log($"  - Slope from ({start.x:F2}, {start.y:F2}) to ({end.x:F2}, {end.y:F2}) at {angle:F1}°");
            }
        }
    }
    
    /// <summary>
    /// Find segments in the path that represent problematic 45° slopes
    /// </summary>
    private List<ProblematicSegment> FindProblematicSlopes(List<Vector2> pathPoints, HashSet<Vector3Int> lShapeTilePositions)
    {
        var problematicSegments = new List<ProblematicSegment>();
        
        for (int i = 0; i < pathPoints.Count - 1; i++)
        {
            Vector2 start = pathPoints[i];
            Vector2 end = pathPoints[(i + 1) % pathPoints.Count];
            
            // Calculate the angle of this segment
            Vector2 direction = (end - start).normalized;
            float angle = Mathf.Atan2(direction.y, direction.x) * Mathf.Rad2Deg;
            
            // Normalize angle to 0-360
            if (angle < 0) angle += 360f;
            
            // Check if this is a diagonal slope within our target range
            bool isDiagonalSlope = IsAngleInRange(angle, 45f, minSlopeAngle, maxSlopeAngle) ||
                                  IsAngleInRange(angle, 135f, minSlopeAngle, maxSlopeAngle) ||
                                  IsAngleInRange(angle, 225f, minSlopeAngle, maxSlopeAngle) ||
                                  IsAngleInRange(angle, 315f, minSlopeAngle, maxSlopeAngle);
            
            if (isDiagonalSlope && IsNearLShapeTile(start, end, lShapeTilePositions))
            {
                problematicSegments.Add(new ProblematicSegment
                {
                    startIndex = i,
                    endIndex = (i + 1) % pathPoints.Count,
                    angle = angle
                });
            }
        }
        
        return problematicSegments;
    }
    
    /// <summary>
    /// Check if an angle is within a target range
    /// </summary>
    private bool IsAngleInRange(float angle, float target, float minOffset, float maxOffset)
    {
        float min = target - minOffset;
        float max = target + maxOffset;
        
        // Handle wrap-around for angles near 0/360
        if (min < 0)
        {
            return angle >= (360f + min) || angle <= max;
        }
        if (max > 360f)
        {
            return angle >= min || angle <= (max - 360f);
        }
        
        return angle >= min && angle <= max;
    }
    
    /// <summary>
    /// Check if a line segment is near any L-shaped tiles
    /// </summary>
    private bool IsNearLShapeTile(Vector2 start, Vector2 end, HashSet<Vector3Int> lShapeTilePositions)
    {
        // Check if either endpoint is within an L-shaped tile
        Vector3Int startCell = tilemap.WorldToCell(start);
        Vector3Int endCell = tilemap.WorldToCell(end);
        
        return lShapeTilePositions.Contains(startCell) || lShapeTilePositions.Contains(endCell);
    }
    
    /// <summary>
    /// Data structure to represent a problematic slope segment
    /// </summary>
    private struct ProblematicSegment
    {
        public int startIndex;
        public int endIndex;
        public float angle;
    }
}